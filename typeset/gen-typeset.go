// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package typeset

import (
	"encoding/json"
	"fmt"
)

type StringToKeyFn func(string) ([]byte, error)

type StringSet struct {
	contents map[string]bool
	toKey    StringToKeyFn
}

func StringJSONKeyFn(t string) ([]byte, error) {
	return json.Marshal(t)
}

func StringStringyKeyFn(t string) ([]byte, error) {
	return []byte(fmt.Sprintf("%v", t)), nil
}

func NewStringSet(toKey StringToKeyFn) StringSet {
	return StringSet{
		contents: make(map[string]bool),
		toKey:    toKey,
	}
}

func (ts StringSet) Contains(t string) (bool, error) {
	k, e := ts.toKey(t)
	if e != nil {
		return false, e
	}

	_, hasT := ts.contents[string(k)]
	return hasT, nil
}

func (ts StringSet) Add(t string) error {
	k, e := ts.toKey(t)
	if e != nil {
		return e
	}

	ts.contents[string(k)] = true
	return nil
}

func (ts StringSet) MarshalJSON() ([]byte, error) {
	var c []string
	for k, _ := range ts.contents {
		c = append(c, k)
	}

	return json.Marshal(c)
}

func (ts StringSet) UnmarshalJSON(data []byte) error {
	if ts.toKey == nil {
		return fmt.Errorf("Could not unmarshal into StringSet, toKey function unset")
	}

	var s []string
	e := json.Unmarshal(data, &s)
	if e != nil {
		return e
	}

	ts.contents = make(map[string]bool)
	for _, v := range s {
		ts.contents[v] = true
	}

	return nil
}

type IntToKeyFn func(int) ([]byte, error)

type IntSet struct {
	contents map[string]bool
	toKey    IntToKeyFn
}

func IntJSONKeyFn(t int) ([]byte, error) {
	return json.Marshal(t)
}

func IntStringyKeyFn(t int) ([]byte, error) {
	return []byte(fmt.Sprintf("%v", t)), nil
}

func NewIntSet(toKey IntToKeyFn) IntSet {
	return IntSet{
		contents: make(map[string]bool),
		toKey:    toKey,
	}
}

func (ts IntSet) Contains(t int) (bool, error) {
	k, e := ts.toKey(t)
	if e != nil {
		return false, e
	}

	_, hasT := ts.contents[string(k)]
	return hasT, nil
}

func (ts IntSet) Add(t int) error {
	k, e := ts.toKey(t)
	if e != nil {
		return e
	}

	ts.contents[string(k)] = true
	return nil
}

func (ts IntSet) MarshalJSON() ([]byte, error) {
	var c []string
	for k, _ := range ts.contents {
		c = append(c, k)
	}

	return json.Marshal(c)
}

func (ts IntSet) UnmarshalJSON(data []byte) error {
	if ts.toKey == nil {
		return fmt.Errorf("Could not unmarshal into IntSet, toKey function unset")
	}

	var s []string
	e := json.Unmarshal(data, &s)
	if e != nil {
		return e
	}

	ts.contents = make(map[string]bool)
	for _, v := range s {
		ts.contents[v] = true
	}

	return nil
}
